- [#A] #Graph/Toolsresearch Documentar todos los repos de **didactica** y darles un grafo propio
- [#A] #Toolsresearch Continuar con la boilerplate de Mocha que está en 10-desktop
- [#A] Hay cosas en OneDrive, deberíamos tener una política de qué vamos a hacer. El pago es en Marzo, pero debemos tener acceso por parte de la US. ¿Vamos a seguir dependiendo de esto?
- [#A] #Python Documentar #procesar
  collapsed:: true
  - ``` python

          def get_yaml_schema_validator(self, as_list_item=False) -> str:

            out = {
              "process": "schema_validator",
              "schema": self.schema.name,
              "table": self.name,
              "columns": []
            }

            out["columns"] = [ x.as_dict() for x in list(self.columns.values()) ]

            y = yaml.dump(out, sort_keys=False, default_flow_style=False)

            if as_list_item:
              lines = y.split("\n")
              out_str = "- %s" % lines[0]

              for i in y.split("\n")[1:]:
                out_str = "%s\n  %s" % (out_str, i)

              return out_str

            else:
              return y


           def __str__(self): MAGIC METHODS
            return "%s (%s)" % (self.name, self.udt_name)




          # --------------------------------------
          #
          # __eq__
          #
          # --------------------------------------
          def __eq__(self, column: any) -> bool:
            """Equality in name and data type."""
            if self.name != column.name or self.udt_name != column.udt_name:
              return False
            else:
              return True







            # --------------------------------------
        #
        # Base column class, the one to be used if not a specialized one
        # is defined.
        #
        # --------------------------------------
        class BaseColumn():
          """Base column, the default column type class."""

          # --------------------------------------
          #
          # name
          #
          # --------------------------------------
          name: str = None
          """Column name."""

          # --------------------------------------
          #
          # position
          #
          # --------------------------------------
          position: int = None
          """Position in table."""

          # --------------------------------------
          #
          # udt_name
          #
          # --------------------------------------
          udt_name: str = None
          """Data type name."""

          # --------------------------------------
          #
          # Constructor
          #
          # --------------------------------------
          def __init__(self, **kwargs):
            """Constructor.

            BaseColumns are equal if they have the same name and data type.

            A dictionary of arguments:

              name (string):              Column name.
              position (integer):         Column position in table.
              udt_name (string):          Column data type.
            """
            self.name = kwargs["name"]
            self.position = kwargs["position"] if "position" in kwargs.keys() else None
            self.udt_name = kwargs["udt_name"]

          # # -----------------














        LOGGING >>>



        from .exceptions.errorworkflow import ErrorWorkflow
        import logging

        TODO, DOCUMENT, TIDY

        # --------------------------------------
        #
        # Workflow.
        #
        # --------------------------------------
        class Workflow():

          db = None

          def __init__(self, database):
            self.db = database

          def executeWorkflow(self, workflow, path=None):
            # Process folder
            cur_dir = path if path else os.getcwd()

            wf = None

            logging.info("Starting processing workflows in '%s'" % workflow)

            with open(os.path.join(cur_dir, workflow), "r") as f:
              wf = yaml.safe_load(f.read())

            for w in wf:
              if "process" not in w.keys():
                raise ErrorWorkflow(w, "Malformed workflow, no 'process' item found")

              if w["process"] == "schema_validator":
                logging.info("Processing process %s (%s)" % (w["name"], w["process"]))
                # try:
                work = SchemaValidator(self.db)
                work.execute(w)
                # except Exception as e:
                #   raise ErrorWorkflow(w, e.message)
              # else:
              #   raise ErrorWorkflow(w)

            logging.info("Finished processing workflows")

















        logging.basicConfig(handlers=[
            logging.FileHandler("debug.log"),
            logging.StreamHandler()
          ],
          format="%(asctime)s [%(levelname)s] %(message)s",

          datefmt='%H:%M:%S',
          level=logging.INFO
        )




        # --------------------------------------
        #
        # Main subcommands container.
        #
        # --------------------------------------
        @click.group()
        def cli():
          pass

        # --------------------------------------
        #
        # Run command.
        #
        # ::TODO::
        #
        # --------------------------------------
        @click.command()
        def run():
          """Run command help documentation.

          What happens if multiparagraph?
          """
          run_workflow()

        @click.command()
        @click.option("--column_name_prefix", default="", help="DOCUMENT THIS")
        @click.option("--alias_prefix", default="", help="DOCUMENT THIS")
        @click.option("--target_column", default=0, help="DOCUMENT THIS")
        @click.option("--padding", default=0, help="DOCUMENT THIS")
        @click.argument("schema", required=True)
        @click.argument("table", required=True)
        def fromasprefixed(schema, table, column_name_prefix, alias_prefix,
          target_column, padding):
          """DOCUMENT THIS.

          schema
          table
          """
          from_as_prefixed(schema, table, column_name_prefix, alias_prefix,
            target_column, padding)

        # --------------------------------------
        #
        # Command registry.
        #
        # --------------------------------------
        cli.add_command(run)
        cli.add_command(fromasprefixed)

        cli()








              #
          # --------------------------------------
          def __init__(self, database: Database):
            super().__init__(database)

          def execute(self, args):
            # Convert args to column objects
            expected_columns = [ columnFactory(**column) for column in args["columns"] ]




    ```
  - ``` python

          @contextmanager
          def get_connection(self):
            """Returns a connection to use within a with context manager.

            Yields:
                psycopg.connection: A connection to the database.
            """
            conn = psycopg.connect(self.env.get_connection_data())

            try:
              yield conn
            # except Exception as e:
            #   raise e
            finally:
              conn.close()

          def get_schema(self, name):
            """Returns a Schema object.

            Args:
                name (string): Name of the schema to generate.
            """
            return Schema(name, self)




          yaml.dump(data, sort_keys=False)
        >> print(yaml.dump(yaml.load(document), default_flow_style=False))


        with open(path, "w", encoding = "utf-8") as yaml_file:
            dump = pyyaml.dump(self.dict, default_flow_style = False, allow_unicode = True, encoding = None)
            yaml_file.write( dump )
    ```
- [#A] Revisar y documentar los shortcuts de teclado de Ubuntu Gnome en euler y helios
  collapsed:: true
  :LOGBOOK:
  CLOCK: [2022-11-17 Thu 09:19:03]--[2022-11-17 Thu 09:33:48] =>  00:14:45
  :END:
  - Revisar euler, helios hecho
- [#A] Documentar el nuevo script de substitución de Logseq
